public class MyBtree {



    //m阶B树的插入关键字k
    /*
        0.计算得到m阶B树，关键字最大个数为max=m-1,最小为min=ceil(m/2)-1   [向上取整也可以为((m+1)/2)-1]
        1.首先查询到插入的终端结点位置x[插入的结点一定是终端结点]
        2.开始插入
            分为两种情况：(终端结点当前关键值个数n)
            (1) 终端结点x的关键值个数 < max,直接插入（结束）
            (2) 终端结点x的关键值个数 > max,直接插入后再进行结点分裂
                    结点分裂算法： 提升结点为第 ceil(max/2) 个关键字到父结点,两边形成其左右子树
                                   提升后若父结点关键字溢出,则继续向上提升，直到树升高一层为止。
    *
     */


    //m阶B树的删除关键字k
    /*
        0.计算得到m阶B树，关键字最大个数为max=m-1,最小为min=ceil(m/2)-1   [向上取整也可以为((m+1)/2)-1]
        1.首先寻找关键字位置,有三种情况：
            (1) 查找结果为叶子结点，查找失败，结点不在B树中
            (2) 查找结果为终端结点:
                此时有三种情况：
                    (1) 删除前关键字个数 > min : 直接删除结点（结束）
                    (2) 删除前关键字个数 = min (兄弟够借):  （两种情况）
                            （1）左兄弟关键字 > min , 将左兄弟和当前结点所夹的父关键字并入当前结点，将左兄弟中最大关键字提升为父结点 （结束）
                            （2）右兄弟关键字 > min , 将右兄弟和当前结点所夹的父关键字并入当前结点，将右兄弟中最大关键字提升为父结点 （结束）
                    (3) 删除前关键字个数 = min (兄弟不够借):
                            分两种情况（任选一种即可）：
                                （1）<如果左兄弟存在>将左兄弟结点以及所夹的父关键字全部并入当前结点，将要删除的结点移除，此时当前结点个数为max,
                                （2）<如果右兄弟存在>将右兄弟结点以及所夹的父关键字全部并入当前结点，将要删除的结点移除，此时当前结点个数为max,
                            因为上述操作减少了一个父结点的关键字个数，如果此时父结点关键字个数小于min，则父结点需要问兄弟结点借关键字，
                                够借则结束，
                                不够借则再次与兄弟结点以及其父结点合并，以此类推直至到根结点为止（树高度降低一层）
            (3) 查找结果为非叶子结点也非终端结点：
                    （1）如果直接前驱所在的结点关键字个数 > min 则交换k与直接前驱，然后按照关键字在终端结点上的方式进行删除
                    （2）如果直接后继所在的结点关键字个数 > min 则交换k与直接后继，然后按照关键字在终端结点上的方式进行删除
                    （1）如果直接前驱和直接后继所在的结点关键字个数都 = min，则任选一个交换，然后按照关键字在终端结点上的方式进行删除



    * */



    public static void main(String[] args) {



        











    }
}
